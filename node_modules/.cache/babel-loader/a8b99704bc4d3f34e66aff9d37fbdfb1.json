{"ast":null,"code":"var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\nvar _dom = require(\"./dom\");\n\nvar isCanvasEl = _dom.isCanvasEl;\nvar transformCoordWithViewport = _dom.transformCoordWithViewport;\n/**\r\n * Utilities for mouse or touch events.\r\n */\n\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\nvar _calcOut = [];\n/**\r\n * Get the `zrX` and `zrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * CSS transform (2D & 3D) is supported.\r\n *\r\n * The strategy to fetch the coords:\r\n * + If `calculate` is not set as `true`, users of this method should\r\n * ensure that `el` is the same or the same size & location as `e.target`.\r\n * Otherwise the result coords are probably not expected. Because we\r\n * firstly try to get coords from e.offsetX/e.offsetY.\r\n * + If `calculate` is set as `true`, the input `el` can be any element\r\n * and we force to calculate the coords based on `el`.\r\n * + The input `el` should be positionable (not position:static).\r\n *\r\n * The force `calculate` can be used in case like:\r\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} e Mouse event or touch event.\r\n * @param {Object} out Get `out.zrX` and `out.zrY` as the result.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n */\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n\n  if (calculate || !env.canvasSupported) {\n    calculateZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          calculateZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction calculateZrXY(el, e, out) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\n  if (env.domSupported && el.getBoundingClientRect) {\n    var ex = e.clientX;\n    var ey = e.clientY;\n\n    if (isCanvasEl(el)) {\n      // Original approach, which do not support CSS transform.\n      // marker can not be locationed in a canvas container\n      // (getBoundingClientRect is always 0). We do not support\n      // that input a pre-created canvas to zr while using css\n      // transform in iOS.\n      var box = el.getBoundingClientRect();\n      out.zrX = ex - box.left;\n      out.zrY = ey - box.top;\n      return;\n    } else {\n      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {\n        out.zrX = _calcOut[0];\n        out.zrY = _calcOut[1];\n        return;\n      }\n    }\n  }\n\n  out.zrX = out.zrY = 0;\n}\n/**\r\n * Find native event compat for legency IE.\r\n * Should be called at the begining of a native event listener.\r\n *\r\n * @param {Event} [e] Mouse event or touch event or pointer event.\r\n *        For lagency IE, we use `window.event` is used.\r\n * @return {Event} The native event.\r\n */\n\n\nfunction getNativeEvent(e) {\n  return e || window.event;\n}\n/**\r\n * Normalize the coordinates of the input event.\r\n *\r\n * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * Get `e.zrDelta` if using mouse wheel.\r\n * Get `e.which`, see the comment inside this function.\r\n *\r\n * Do not calculate repeatly if `zrX` and `zrY` already exist.\r\n *\r\n * Notice: see comments in `clientToLocal`. check the relationship\r\n * between the result coords and the parameters `el` and `calculate`.\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} [e] See `getNativeEvent`.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n * @return {UIEvent} The normalized native UIEvent.\r\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = getNativeEvent(e);\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, it may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\n  // `mousedown (pointerdown)` is the same as Chrome does.\n\n\n  return e;\n}\n/**\r\n * @param {HTMLElement} el\r\n * @param {string} name\r\n * @param {Function} handler\r\n * @param {Object|boolean} opt If boolean, means `opt.capture`\r\n * @param {boolean} [opt.capture=false]\r\n * @param {boolean} [opt.passive=false]\r\n */\n\n\nfunction addEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    // Reproduct the console warning:\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\n    // Consider marking event handler as 'passive' to make the page more responsive.\n    // Just set console log level: verbose in chrome dev tool.\n    // then the warning log will be printed when addEventListener called.\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // We have not yet found a neat way to using passive. Because in zrender the dom event\n    // listener delegate all of the upper events of element. Some of those events need\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\n    // Before passive can be adopted, these issues should be considered:\n    // (1) Whether and how a zrender user specifies an event listener passive. And by default,\n    // passive or not.\n    // (2) How to tread that some zrender event listener is passive, and some is not. If\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\n    // compatibility should be handled.\n    // var opts = (env.passiveSupported && name === 'mousewheel')\n    //     ? {passive: true}\n    //     // By default, the third param of el.addEventListener is `capture: false`.\n    //     : void 0;\n    // el.addEventListener(name, handler /* , opts */);\n    el.addEventListener(name, handler, opt);\n  } else {\n    // For simplicity, do not implement `setCapture` for IE9-.\n    el.attachEvent('on' + name, handler);\n  }\n}\n/**\r\n * Parameter are the same as `addEventListener`.\r\n *\r\n * Notice that if a listener is registered twice, one with capture and one without,\r\n * remove each one separately. Removal of a capturing listener does not affect a\r\n * non-capturing version of the same listener, and vice versa.\r\n */\n\n\nfunction removeEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler, opt);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\r\n * preventDefault and stopPropagation.\r\n * Notice: do not use this method in zrender. It can only be\r\n * used by upper applications if necessary.\r\n *\r\n * @param {Event} e A mouse or touch event.\r\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n/**\r\n * This method only works for mouseup and mousedown. The functionality is restricted\r\n * for fault tolerance, See the `e.which` compatibility above.\r\n *\r\n * @param {MouseEvent} e\r\n * @return {boolean}\r\n */\n\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\n  return e.which === 2 || e.which === 3;\n}\n/**\r\n * To be removed.\r\n * @deprecated\r\n */\n\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // For backward compatibility\n\n\nexports.clientToLocal = clientToLocal;\nexports.getNativeEvent = getNativeEvent;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\nexports.notLeftMouse = notLeftMouse;","map":{"version":3,"sources":["D:/code/web/jarvis-web/node_modules/zrender/lib/core/event.js"],"names":["Eventful","require","exports","Dispatcher","env","_dom","isCanvasEl","transformCoordWithViewport","isDomLevel2","window","addEventListener","MOUSE_EVENT_REG","_calcOut","clientToLocal","el","e","out","calculate","canvasSupported","calculateZrXY","browser","firefox","layerX","offsetX","zrX","zrY","layerY","offsetY","domSupported","getBoundingClientRect","ex","clientX","ey","clientY","box","left","top","getNativeEvent","event","normalizeEvent","eventType","type","isTouch","indexOf","zrDelta","wheelDelta","detail","touch","targetTouches","changedTouches","button","which","undefined","test","name","handler","opt","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","isMiddleOrRightButtonOnMouseUpDown","notLeftMouse"],"mappings":"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","sourcesContent":["var Eventful = require(\"../mixin/Eventful\");\r\n\r\nexports.Dispatcher = Eventful;\r\n\r\nvar env = require(\"./env\");\r\n\r\nvar _dom = require(\"./dom\");\r\n\r\nvar isCanvasEl = _dom.isCanvasEl;\r\nvar transformCoordWithViewport = _dom.transformCoordWithViewport;\r\n\r\n/**\r\n * Utilities for mouse or touch events.\r\n */\r\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\r\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\r\nvar _calcOut = [];\r\n/**\r\n * Get the `zrX` and `zrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * CSS transform (2D & 3D) is supported.\r\n *\r\n * The strategy to fetch the coords:\r\n * + If `calculate` is not set as `true`, users of this method should\r\n * ensure that `el` is the same or the same size & location as `e.target`.\r\n * Otherwise the result coords are probably not expected. Because we\r\n * firstly try to get coords from e.offsetX/e.offsetY.\r\n * + If `calculate` is set as `true`, the input `el` can be any element\r\n * and we force to calculate the coords based on `el`.\r\n * + The input `el` should be positionable (not position:static).\r\n *\r\n * The force `calculate` can be used in case like:\r\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} e Mouse event or touch event.\r\n * @param {Object} out Get `out.zrX` and `out.zrY` as the result.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n */\r\n\r\nfunction clientToLocal(el, e, out, calculate) {\r\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\r\n  // to the padding edge of the target element. The only browser using this convention\r\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\r\n  // not support the properties.\r\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\r\n  // In zr painter.dom, padding edge equals to border edge.\r\n\r\n  if (calculate || !env.canvasSupported) {\r\n    calculateZrXY(el, e, out);\r\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\r\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\r\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\r\n  // zoom-factor, overflow / opacity layers, transforms ...)\r\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\r\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\r\n  // BTW3, In ff, offsetX/offsetY is always 0.\r\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\r\n      out.zrX = e.layerX;\r\n      out.zrY = e.layerY;\r\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\r\n    else if (e.offsetX != null) {\r\n        out.zrX = e.offsetX;\r\n        out.zrY = e.offsetY;\r\n      } // For some other device, e.g., IOS safari.\r\n      else {\r\n          calculateZrXY(el, e, out);\r\n        }\r\n\r\n  return out;\r\n}\r\n\r\nfunction calculateZrXY(el, e, out) {\r\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\r\n  if (env.domSupported && el.getBoundingClientRect) {\r\n    var ex = e.clientX;\r\n    var ey = e.clientY;\r\n\r\n    if (isCanvasEl(el)) {\r\n      // Original approach, which do not support CSS transform.\r\n      // marker can not be locationed in a canvas container\r\n      // (getBoundingClientRect is always 0). We do not support\r\n      // that input a pre-created canvas to zr while using css\r\n      // transform in iOS.\r\n      var box = el.getBoundingClientRect();\r\n      out.zrX = ex - box.left;\r\n      out.zrY = ey - box.top;\r\n      return;\r\n    } else {\r\n      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {\r\n        out.zrX = _calcOut[0];\r\n        out.zrY = _calcOut[1];\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  out.zrX = out.zrY = 0;\r\n}\r\n/**\r\n * Find native event compat for legency IE.\r\n * Should be called at the begining of a native event listener.\r\n *\r\n * @param {Event} [e] Mouse event or touch event or pointer event.\r\n *        For lagency IE, we use `window.event` is used.\r\n * @return {Event} The native event.\r\n */\r\n\r\n\r\nfunction getNativeEvent(e) {\r\n  return e || window.event;\r\n}\r\n/**\r\n * Normalize the coordinates of the input event.\r\n *\r\n * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * Get `e.zrDelta` if using mouse wheel.\r\n * Get `e.which`, see the comment inside this function.\r\n *\r\n * Do not calculate repeatly if `zrX` and `zrY` already exist.\r\n *\r\n * Notice: see comments in `clientToLocal`. check the relationship\r\n * between the result coords and the parameters `el` and `calculate`.\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} [e] See `getNativeEvent`.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n * @return {UIEvent} The normalized native UIEvent.\r\n */\r\n\r\n\r\nfunction normalizeEvent(el, e, calculate) {\r\n  e = getNativeEvent(e);\r\n\r\n  if (e.zrX != null) {\r\n    return e;\r\n  }\r\n\r\n  var eventType = e.type;\r\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\r\n\r\n  if (!isTouch) {\r\n    clientToLocal(el, e, e, calculate);\r\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\r\n  } else {\r\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\r\n    touch && clientToLocal(el, touch, e, calculate);\r\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\r\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\r\n  // If e.which has been defined, it may be readonly,\r\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\r\n\r\n\r\n  var button = e.button;\r\n\r\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\r\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\r\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\r\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\r\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\r\n  // `mousedown (pointerdown)` is the same as Chrome does.\r\n\r\n\r\n  return e;\r\n}\r\n/**\r\n * @param {HTMLElement} el\r\n * @param {string} name\r\n * @param {Function} handler\r\n * @param {Object|boolean} opt If boolean, means `opt.capture`\r\n * @param {boolean} [opt.capture=false]\r\n * @param {boolean} [opt.passive=false]\r\n */\r\n\r\n\r\nfunction addEventListener(el, name, handler, opt) {\r\n  if (isDomLevel2) {\r\n    // Reproduct the console warning:\r\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\r\n    // Consider marking event handler as 'passive' to make the page more responsive.\r\n    // Just set console log level: verbose in chrome dev tool.\r\n    // then the warning log will be printed when addEventListener called.\r\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n    // We have not yet found a neat way to using passive. Because in zrender the dom event\r\n    // listener delegate all of the upper events of element. Some of those events need\r\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\r\n    // Before passive can be adopted, these issues should be considered:\r\n    // (1) Whether and how a zrender user specifies an event listener passive. And by default,\r\n    // passive or not.\r\n    // (2) How to tread that some zrender event listener is passive, and some is not. If\r\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\r\n    // compatibility should be handled.\r\n    // var opts = (env.passiveSupported && name === 'mousewheel')\r\n    //     ? {passive: true}\r\n    //     // By default, the third param of el.addEventListener is `capture: false`.\r\n    //     : void 0;\r\n    // el.addEventListener(name, handler /* , opts */);\r\n    el.addEventListener(name, handler, opt);\r\n  } else {\r\n    // For simplicity, do not implement `setCapture` for IE9-.\r\n    el.attachEvent('on' + name, handler);\r\n  }\r\n}\r\n/**\r\n * Parameter are the same as `addEventListener`.\r\n *\r\n * Notice that if a listener is registered twice, one with capture and one without,\r\n * remove each one separately. Removal of a capturing listener does not affect a\r\n * non-capturing version of the same listener, and vice versa.\r\n */\r\n\r\n\r\nfunction removeEventListener(el, name, handler, opt) {\r\n  if (isDomLevel2) {\r\n    el.removeEventListener(name, handler, opt);\r\n  } else {\r\n    el.detachEvent('on' + name, handler);\r\n  }\r\n}\r\n/**\r\n * preventDefault and stopPropagation.\r\n * Notice: do not use this method in zrender. It can only be\r\n * used by upper applications if necessary.\r\n *\r\n * @param {Event} e A mouse or touch event.\r\n */\r\n\r\n\r\nvar stop = isDomLevel2 ? function (e) {\r\n  e.preventDefault();\r\n  e.stopPropagation();\r\n  e.cancelBubble = true;\r\n} : function (e) {\r\n  e.returnValue = false;\r\n  e.cancelBubble = true;\r\n};\r\n/**\r\n * This method only works for mouseup and mousedown. The functionality is restricted\r\n * for fault tolerance, See the `e.which` compatibility above.\r\n *\r\n * @param {MouseEvent} e\r\n * @return {boolean}\r\n */\r\n\r\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\r\n  return e.which === 2 || e.which === 3;\r\n}\r\n/**\r\n * To be removed.\r\n * @deprecated\r\n */\r\n\r\n\r\nfunction notLeftMouse(e) {\r\n  // If e.which is undefined, considered as left mouse event.\r\n  return e.which > 1;\r\n} // For backward compatibility\r\n\r\n\r\nexports.clientToLocal = clientToLocal;\r\nexports.getNativeEvent = getNativeEvent;\r\nexports.normalizeEvent = normalizeEvent;\r\nexports.addEventListener = addEventListener;\r\nexports.removeEventListener = removeEventListener;\r\nexports.stop = stop;\r\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\r\nexports.notLeftMouse = notLeftMouse;"]},"metadata":{},"sourceType":"script"}