{"ast":null,"code":"/**\r\n * Sub-pixel optimize for canvas rendering, prevent from blur\r\n * when rendering a thin vertical/horizontal line.\r\n */\nvar round = Math.round;\n/**\r\n * Sub pixel optimize line for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {number} [inputShape.x1]\r\n * @param {number} [inputShape.y1]\r\n * @param {number} [inputShape.x2]\r\n * @param {number} [inputShape.y2]\r\n * @param {Object} [style]\r\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\r\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  if (!inputShape) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n  outputShape.x1 = x1;\n  outputShape.x2 = x2;\n  outputShape.y1 = y1;\n  outputShape.y2 = y2;\n  var lineWidth = style && style.lineWidth;\n\n  if (!lineWidth) {\n    return;\n  }\n\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  }\n\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  }\n}\n/**\r\n * Sub pixel optimize rect for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {number} [inputShape.x]\r\n * @param {number} [inputShape.y]\r\n * @param {number} [inputShape.width]\r\n * @param {number} [inputShape.height]\r\n * @param {Object} [style]\r\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\r\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  if (!inputShape) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = originX;\n  outputShape.y = originY;\n  outputShape.width = originWidth;\n  outputShape.height = originHeight;\n  var lineWidth = style && style.lineWidth;\n\n  if (!lineWidth) {\n    return;\n  }\n\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param {number} position Coordinate, such as x, y\r\n * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.\r\n * @param {boolean=} positiveOrNegative Default false (negative).\r\n * @return {number} Optimized position.\r\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  if (!lineWidth) {\n    return position;\n  } // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n\n\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;","map":{"version":3,"sources":["D:/code/web/jarvis-web/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js"],"names":["round","Math","subPixelOptimizeLine","outputShape","inputShape","style","x1","x2","y1","y2","lineWidth","subPixelOptimize","subPixelOptimizeRect","originX","x","originY","y","originWidth","width","originHeight","height","max","position","positiveOrNegative","doubledPosition","exports"],"mappings":"AAAA;;;;AAIA,IAAIA,KAAK,GAAGC,IAAI,CAACD,KAAjB;AACA;;;;;;;;;;;;;;;;AAgBA,SAASE,oBAAT,CAA8BC,WAA9B,EAA2CC,UAA3C,EAAuDC,KAAvD,EAA8D;AAC5D,MAAI,CAACD,UAAL,EAAiB;AACf;AACD;;AAED,MAAIE,EAAE,GAAGF,UAAU,CAACE,EAApB;AACA,MAAIC,EAAE,GAAGH,UAAU,CAACG,EAApB;AACA,MAAIC,EAAE,GAAGJ,UAAU,CAACI,EAApB;AACA,MAAIC,EAAE,GAAGL,UAAU,CAACK,EAApB;AACAN,EAAAA,WAAW,CAACG,EAAZ,GAAiBA,EAAjB;AACAH,EAAAA,WAAW,CAACI,EAAZ,GAAiBA,EAAjB;AACAJ,EAAAA,WAAW,CAACK,EAAZ,GAAiBA,EAAjB;AACAL,EAAAA,WAAW,CAACM,EAAZ,GAAiBA,EAAjB;AACA,MAAIC,SAAS,GAAGL,KAAK,IAAIA,KAAK,CAACK,SAA/B;;AAEA,MAAI,CAACA,SAAL,EAAgB;AACd;AACD;;AAED,MAAIV,KAAK,CAACM,EAAE,GAAG,CAAN,CAAL,KAAkBN,KAAK,CAACO,EAAE,GAAG,CAAN,CAA3B,EAAqC;AACnCJ,IAAAA,WAAW,CAACG,EAAZ,GAAiBH,WAAW,CAACI,EAAZ,GAAiBI,gBAAgB,CAACL,EAAD,EAAKI,SAAL,EAAgB,IAAhB,CAAlD;AACD;;AAED,MAAIV,KAAK,CAACQ,EAAE,GAAG,CAAN,CAAL,KAAkBR,KAAK,CAACS,EAAE,GAAG,CAAN,CAA3B,EAAqC;AACnCN,IAAAA,WAAW,CAACK,EAAZ,GAAiBL,WAAW,CAACM,EAAZ,GAAiBE,gBAAgB,CAACH,EAAD,EAAKE,SAAL,EAAgB,IAAhB,CAAlD;AACD;AACF;AACD;;;;;;;;;;;;;;;;;AAiBA,SAASE,oBAAT,CAA8BT,WAA9B,EAA2CC,UAA3C,EAAuDC,KAAvD,EAA8D;AAC5D,MAAI,CAACD,UAAL,EAAiB;AACf;AACD;;AAED,MAAIS,OAAO,GAAGT,UAAU,CAACU,CAAzB;AACA,MAAIC,OAAO,GAAGX,UAAU,CAACY,CAAzB;AACA,MAAIC,WAAW,GAAGb,UAAU,CAACc,KAA7B;AACA,MAAIC,YAAY,GAAGf,UAAU,CAACgB,MAA9B;AACAjB,EAAAA,WAAW,CAACW,CAAZ,GAAgBD,OAAhB;AACAV,EAAAA,WAAW,CAACa,CAAZ,GAAgBD,OAAhB;AACAZ,EAAAA,WAAW,CAACe,KAAZ,GAAoBD,WAApB;AACAd,EAAAA,WAAW,CAACiB,MAAZ,GAAqBD,YAArB;AACA,MAAIT,SAAS,GAAGL,KAAK,IAAIA,KAAK,CAACK,SAA/B;;AAEA,MAAI,CAACA,SAAL,EAAgB;AACd;AACD;;AAEDP,EAAAA,WAAW,CAACW,CAAZ,GAAgBH,gBAAgB,CAACE,OAAD,EAAUH,SAAV,EAAqB,IAArB,CAAhC;AACAP,EAAAA,WAAW,CAACa,CAAZ,GAAgBL,gBAAgB,CAACI,OAAD,EAAUL,SAAV,EAAqB,IAArB,CAAhC;AACAP,EAAAA,WAAW,CAACe,KAAZ,GAAoBjB,IAAI,CAACoB,GAAL,CAASV,gBAAgB,CAACE,OAAO,GAAGI,WAAX,EAAwBP,SAAxB,EAAmC,KAAnC,CAAhB,GAA4DP,WAAW,CAACW,CAAjF,EAAoFG,WAAW,KAAK,CAAhB,GAAoB,CAApB,GAAwB,CAA5G,CAApB;AACAd,EAAAA,WAAW,CAACiB,MAAZ,GAAqBnB,IAAI,CAACoB,GAAL,CAASV,gBAAgB,CAACI,OAAO,GAAGI,YAAX,EAAyBT,SAAzB,EAAoC,KAApC,CAAhB,GAA6DP,WAAW,CAACa,CAAlF,EAAqFG,YAAY,KAAK,CAAjB,GAAqB,CAArB,GAAyB,CAA9G,CAArB;AACD;AACD;;;;;;;;;;AAUA,SAASR,gBAAT,CAA0BW,QAA1B,EAAoCZ,SAApC,EAA+Ca,kBAA/C,EAAmE;AACjE,MAAI,CAACb,SAAL,EAAgB;AACd,WAAOY,QAAP;AACD,GAHgE,CAG/D;AACF;;;AAGA,MAAIE,eAAe,GAAGxB,KAAK,CAACsB,QAAQ,GAAG,CAAZ,CAA3B;AACA,SAAO,CAACE,eAAe,GAAGxB,KAAK,CAACU,SAAD,CAAxB,IAAuC,CAAvC,KAA6C,CAA7C,GAAiDc,eAAe,GAAG,CAAnE,GAAuE,CAACA,eAAe,IAAID,kBAAkB,GAAG,CAAH,GAAO,CAAC,CAA9B,CAAhB,IAAoD,CAAlI;AACD;;AAEDE,OAAO,CAACvB,oBAAR,GAA+BA,oBAA/B;AACAuB,OAAO,CAACb,oBAAR,GAA+BA,oBAA/B;AACAa,OAAO,CAACd,gBAAR,GAA2BA,gBAA3B","sourcesContent":["/**\r\n * Sub-pixel optimize for canvas rendering, prevent from blur\r\n * when rendering a thin vertical/horizontal line.\r\n */\r\nvar round = Math.round;\r\n/**\r\n * Sub pixel optimize line for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {number} [inputShape.x1]\r\n * @param {number} [inputShape.y1]\r\n * @param {number} [inputShape.x2]\r\n * @param {number} [inputShape.y2]\r\n * @param {Object} [style]\r\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\r\n */\r\n\r\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\r\n  if (!inputShape) {\r\n    return;\r\n  }\r\n\r\n  var x1 = inputShape.x1;\r\n  var x2 = inputShape.x2;\r\n  var y1 = inputShape.y1;\r\n  var y2 = inputShape.y2;\r\n  outputShape.x1 = x1;\r\n  outputShape.x2 = x2;\r\n  outputShape.y1 = y1;\r\n  outputShape.y2 = y2;\r\n  var lineWidth = style && style.lineWidth;\r\n\r\n  if (!lineWidth) {\r\n    return;\r\n  }\r\n\r\n  if (round(x1 * 2) === round(x2 * 2)) {\r\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\r\n  }\r\n\r\n  if (round(y1 * 2) === round(y2 * 2)) {\r\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\r\n  }\r\n}\r\n/**\r\n * Sub pixel optimize rect for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {number} [inputShape.x]\r\n * @param {number} [inputShape.y]\r\n * @param {number} [inputShape.width]\r\n * @param {number} [inputShape.height]\r\n * @param {Object} [style]\r\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\r\n */\r\n\r\n\r\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\r\n  if (!inputShape) {\r\n    return;\r\n  }\r\n\r\n  var originX = inputShape.x;\r\n  var originY = inputShape.y;\r\n  var originWidth = inputShape.width;\r\n  var originHeight = inputShape.height;\r\n  outputShape.x = originX;\r\n  outputShape.y = originY;\r\n  outputShape.width = originWidth;\r\n  outputShape.height = originHeight;\r\n  var lineWidth = style && style.lineWidth;\r\n\r\n  if (!lineWidth) {\r\n    return;\r\n  }\r\n\r\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\r\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\r\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\r\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\r\n}\r\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param {number} position Coordinate, such as x, y\r\n * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.\r\n * @param {boolean=} positiveOrNegative Default false (negative).\r\n * @return {number} Optimized position.\r\n */\r\n\r\n\r\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\r\n  if (!lineWidth) {\r\n    return position;\r\n  } // Assure that (position + lineWidth / 2) is near integer edge,\r\n  // otherwise line will be fuzzy in canvas.\r\n\r\n\r\n  var doubledPosition = round(position * 2);\r\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n}\r\n\r\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\r\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\r\nexports.subPixelOptimize = subPixelOptimize;"]},"metadata":{},"sourceType":"script"}